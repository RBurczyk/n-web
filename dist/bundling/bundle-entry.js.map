{"version":3,"file":"bundle-entry.js","sourceRoot":"","sources":["../../src/bundling/bundle-entry.ts"],"names":[],"mappings":";;AAAA,6CAAoC;AACpC,yBAAyB;AACzB,6BAA6B;AAC7B,6CAAgD;AAChD,+CAA2C;AAG3C;IAMI,YAAmB,IAAY;QAE3B,mBAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAE3E,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAEnB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,CAAC;QAEtC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YACrB,MAAM,IAAI,+BAAiB,CAAC,SAAS,IAAI,GAAG,EAAE,gBAAgB,CAAC,CAAC;QAEpE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,CAAC;IAClD,CAAC;IAGM,QAAQ,CAAC,SAAkB;QAE9B,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;QAEhD,IAAI,MAAM,GAAG,IAAI,KAAK,EAAc,CAAC;QACrC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;QAC7D,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAGO,wBAAwB,CAAC,IAAY,EAAE,SAAiB,EAAE,WAA8B;QAE5F,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,CAAC,CACrC,CAAC;YACG,EAAE,CAAC,CAAC,SAAS,CAAC,CACd,CAAC;gBACG,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;oBACzB,WAAW,CAAC,IAAI,CAAC,IAAI,wBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,CACJ,CAAC;gBACG,WAAW,CAAC,IAAI,CAAC,IAAI,wBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3C,CAAC;QACL,CAAC;QACD,IAAI,CACJ,CAAC;YACG,IAAI,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACjC,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,KAAK,CAAC;gBACnB,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;QACrF,CAAC;IACL,CAAC;CACJ;AArDD,kCAqDC","sourcesContent":["import { given } from \"n-defensive\";\nimport * as Fs from \"fs\";\nimport * as Path from \"path\";\nimport { ArgumentException } from \"n-exception\";\nimport { BundleFile } from \"./bundle-file\";\n\n\nexport class BundleEntry\n{\n    private readonly _path: string;\n    private readonly _isDir: boolean;\n    \n    \n    public constructor(path: string)\n    {\n        given(path, \"path\").ensureHasValue().ensure(t => !t.isEmptyOrWhiteSpace());\n        \n        path = path.trim();\n        \n        path = Path.join(process.cwd(), path);\n        \n        if (!Fs.existsSync(path))\n            throw new ArgumentException(`path [${path}]`, \"does not exist\");\n\n        this._path = path;\n        this._isDir = Fs.statSync(path).isDirectory();\n    }\n    \n    \n    public getFiles(filterExt?: string): Array<BundleFile>\n    {\n        filterExt = filterExt ? filterExt.trim() : null;\n                \n        let result = new Array<BundleFile>();\n        this.accumulateFilesToProcess(this._path, filterExt, result);\n        return result;\n    }\n    \n    \n    private accumulateFilesToProcess(path: string, filterExt: string, accumulator: Array<BundleFile>): void\n    {\n        if (!Fs.statSync(path).isDirectory())\n        {\n            if (filterExt)\n            {\n                if (path.endsWith(filterExt))\n                    accumulator.push(new BundleFile(path));\n            }\n            else\n            {\n                accumulator.push(new BundleFile(path));\n            }    \n        }\n        else\n        {\n            let files = Fs.readdirSync(path);\n            for (let item of files)\n                this.accumulateFilesToProcess(Path.join(path, item), filterExt, accumulator);\n        }    \n    }\n}"]}